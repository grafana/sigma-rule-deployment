name: "Grafana Query Integration"
description: "Take converted rules and convert them into deployable outputs (alert rules, dashboards, etc.) and test them."
author: "security-operations"

inputs:
  config_path:
    description: "Path to the configuration file for the Sigma Rule Integrator"
    required: true
    default: ""
  grafana_sa_token:
    description: "Service account token for Grafana for query testing"
    required: false
    default: ""
  pretty_print:
    description: "Pretty print the JSON output"
    required: false
    default: "false"
  output_log_lines:
    description: "Output log lines to the outputs of the test_query_results"
    required: false
    default: "false"
  all_rules:
    description: "Whether to integrate all rules"
    required: false
    default: "false"
  changed_files_from_base:
    description: "Whether to use the changed files from the base branch"
    required: false
    default: "false"
  actions_username:
    description: "The username of the actions user"
    required: false
    default: "github-actions[bot]"
  continue_on_query_testing_errors:
    description: "Continue integration process even when query testing fails, but print errors and continue the action"
    required: false
    default: "true"

outputs:
  rules_integrated:
    description: "The repository file names changed (added/updated or removed) by this Action"
    value: ${{ steps.set-output.outputs.rules_integrated }}
  test_query_results:
    description: "The results of testing the queries against the datasource for the past hour"
    value: ${{ steps.set-output.outputs.test_query_results }}

runs:
  using: "composite"
  steps:
    - name: Retrieve conversion and deployment paths from config
      id: config-paths
      shell: bash
      env:
        CONFIG_PATH: ${{ inputs.config_path }}
      run: |
        CONVERSION_PATH=$(yq -r '.folders.conversion_path' "${CONFIG_PATH}")
        echo "conversion_path=${CONVERSION_PATH}" >> $GITHUB_OUTPUT
        DEPLOYMENT_PATH=$(yq -r '.folders.deployment_path' "${CONFIG_PATH}")
        echo "deployment_path=${DEPLOYMENT_PATH}" >> $GITHUB_OUTPUT

    - name: Login to GitHub Container Registry
      uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ github.token }}
    - name: Determine Image Reference
      id: image-ref
      shell: bash
      env:
        ACTION_REF: ${{ github.action_ref }}
      run: |
        # Check if the action_ref is a tag (starts with v followed by numbers/dots)
        if [[ "$ACTION_REF" =~ ^v[0-9]+(\.[0-9]+)*(\.[0-9]+)?$ ]]; then
          echo "image_ref=$ACTION_REF" >> $GITHUB_OUTPUT
          echo "Using tag: $ACTION_REF"
        elif [[ "$ACTION_REF" == "latest" ]]; then
          echo "image_ref=latest" >> $GITHUB_OUTPUT
          echo "Using latest tag"
        else
          echo "image_ref=sha-$ACTION_REF" >> $GITHUB_OUTPUT
          echo "Using SHA: sha-$ACTION_REF"
        fi
    - name: Identify relevant commits
      if: ${{ inputs.changed_files_from_base == 'false' }}
      id: commits
      uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
      env:
        ACTIONS_USERNAME: ${{ inputs.actions_username }}
      with:
        script: |
          const iterator = await github.paginate(github.rest.pulls.listCommits.endpoint.merge({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.payload.pull_request?.number || context.payload.issue?.number,
            per_page: 1
          }));
          let previous_commit = "";
          let first_commit = "";
          let last_commit = "";
          let base_commit = "";
          for (const remote_commit of iterator) {
            if (previous_commit === "" && remote_commit.parents.length > 0) {
              previous_commit = remote_commit.parents[0].sha;
              base_commit = remote_commit.parents[0].sha;
              first_commit = remote_commit.sha;
            }
            if (remote_commit.commit.author.name === process.env.ACTIONS_USERNAME) {
              previous_commit = remote_commit.sha;
              last_commit = remote_commit.sha;
            }
          }
          console.log(`Last commit or base ref: ${previous_commit}`);
          console.log(`PR First Commit: ${first_commit}`);
          console.log(`PR Last Commit by automation: ${last_commit}`);
          console.log(`PR Previous Ref: ${last_commit || previous_commit}`);
          console.log(`PR Base Ref: ${base_commit}`);

          core.setOutput('previous-commit', previous_commit);
          core.setOutput('first-commit', first_commit);
          core.setOutput('last-commit', last_commit);
          core.setOutput('previous-ref', last_commit || previous_commit);
          core.setOutput('base-ref', base_commit);

          return {};
    - name: Calculate Change Files
      id: changed-files
      shell: bash
      env:
        CONVERSION_PATH: ${{ steps.config-paths.outputs.conversion_path }}
        PREVIOUS_REF: ${{ steps.commits.outputs.previous-ref }}
        BASE_REF: ${{ steps.commits.outputs.base-ref }}
      run: |
        git fetch origin
        echo "Using CONVERSION_PATH: $CONVERSION_PATH"
        CHANGED_FILES=$(git diff "$PREVIOUS_REF" --name-only --diff-filter=ACMR -- "$CONVERSION_PATH")
        DELETED_FILES=$(git diff "$PREVIOUS_REF" --name-only --diff-filter=D -- "$CONVERSION_PATH")
        TEST_FILES=$(git diff "$BASE_REF" --name-only --diff-filter=ACMR -- "$CONVERSION_PATH")
        echo all_changed_files=${CHANGED_FILES//\\n/} >> "$GITHUB_OUTPUT"
        echo deleted_files=${DELETED_FILES//\\n/} >> "$GITHUB_OUTPUT"
        echo test_files=${TEST_FILES//\\n/} >> "$GITHUB_OUTPUT"

    - name: Run Sigma Rule Integrator
      id: integrate
      shell: bash
      env:
        CONFIG_PATH: ${{ inputs.config_path }}
        GRAFANA_SA_TOKEN: ${{ inputs.grafana_sa_token }}
        PRETTY_PRINT: ${{ inputs.pretty_print }}
        CHANGED_FILES: ${{ steps.changed-files.outputs.all_changed_files }}
        DELETED_FILES: ${{ steps.changed-files.outputs.deleted_files }}
        TEST_FILES: ${{ steps.changed-files.outputs.test_files }}
        ALL_RULES: ${{ inputs.all_rules }}
        CONTINUE_ON_QUERY_TESTING_ERRORS: ${{ inputs.continue_on_query_testing_errors }}
        IMAGE_REF: ${{ steps.image-ref.outputs.image_ref }}
      run: |
        docker run --rm \
            -v "$(pwd):/sigma-rules" \
            -w /sigma-rules \
            -e GITHUB_OUTPUT=/sigma-rules/github-output \
            -e INTEGRATOR_CONFIG_PATH="$CONFIG_PATH" \
            -e INTEGRATOR_GRAFANA_SA_TOKEN="$GRAFANA_SA_TOKEN" \
            -e PRETTY_PRINT="$PRETTY_PRINT" \
            -e CHANGED_FILES="$CHANGED_FILES" \
            -e DELETED_FILES="$DELETED_FILES" \
            -e TEST_FILES="$TEST_FILES" \
            -e ALL_RULES="$ALL_RULES" \
            -e CONTINUE_ON_QUERY_TESTING_ERRORS="$CONTINUE_ON_QUERY_TESTING_ERRORS" \
            "ghcr.io/grafana/sigma-rule-deployment/sigma-rule-deployer:$IMAGE_REF" \
            integrate
    - name: Set output
      id: set-output
      shell: bash
      run: |
        mv github-output $GITHUB_OUTPUT

    - name: Generate Comment Data
      id: generate-comment-data
      shell: bash
      env:
        BASE_REF: ${{ steps.commits.outputs.base-ref }}
        DEPLOYMENT_PATH: ${{ steps.config-paths.outputs.deployment_path }}
      run: |
        git add "$DEPLOYMENT_PATH"
        CHANGED_FILES=$(git diff "$BASE_REF" --name-only --diff-filter=ACMR -- "$DEPLOYMENT_PATH")
        DELETED_FILES=$(git diff "$BASE_REF" --name-only --diff-filter=D -- "$DEPLOYMENT_PATH")

        echo changed_files=${CHANGED_FILES//\\n/} >> $GITHUB_OUTPUT
        echo deleted_files=${DELETED_FILES//\\n/} >> $GITHUB_OUTPUT

    - name: Comment Integrations
      id: comment-integrations
      uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
      env:
        PULL_REQUEST_NUMBER: ${{ github.event.number || github.event.issue.number }}
        CHANGED_FILES: ${{ steps.generate-comment-data.outputs.changed_files }}
        DELETED_FILES: ${{ steps.generate-comment-data.outputs.deleted_files }}
        TEST_RESULTS: ${{ steps.set-output.outputs.test_query_results }}
      with:
        script: |
          const changedFiles = process.env.CHANGED_FILES.split(' ').filter(file => file.trim() !== '');
          const deletedFiles = process.env.DELETED_FILES.split(' ').filter(file => file.trim() !== '');
          let testResults = {};
          try {
            testResults = JSON.parse(process.env.TEST_RESULTS);
          } catch (e) {
            console.log("No test results found");
          }

          let resultTable = `| File name | Link | Result count | Errors |\n| --- | --- | --- | --- |\n`;

          for (const [key, value] of Object.entries(testResults)) {
            for (const result of value) {
              resultTable += `| ${key} | [See in Explore](${result.link}) | ${result.stats.count} | ${result.stats.errors.length} |\n`;
            }
          }

          const prData = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: process.env.PULL_REQUEST_NUMBER,
          });
          if (!prData.data) {
            console.log(`No pull request found for ${context.repo.owner}/${context.repo.repo}#${process.env.PULL_REQUEST_NUMBER}`);
            return '';
          }

          const nodeId = prData.data.node_id;

          const comment = `
          ### Sigma Rule Integrations

          | Changed | Deleted |
          | --- | --- |
          | ${changedFiles.length} | ${deletedFiles.length} |

          ### Changed Files

          ${changedFiles.length ? changedFiles.map(file => `- [${file}](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/${prData.data.head.ref}/${file})`).join("\n") : "No files changed"}

          ### Deleted Files

          ${deletedFiles.length ? deletedFiles.map(file => `- ${file}`).join("\n") : "No files deleted"}

          ### Test Results

          ${resultTable}
          `;

          const oldCommentQuery = `query GetPRComments($owner: String!, $name: String!, $number: Int!) {
              repository(owner: $owner, name: $name) {
                id
                pullRequest(number: $number) {
                  title
                  comments(last: 100) {
                    nodes {
                      id
                      bodyText
                      isMinimized
                      author {
                        login
                      }
                    }
                  }
                }
              }
          }`;

          const minimizeCommentMutation = `mutation MinimizeComment($subjectId: ID!) {
            minimizeComment(input: {
              subjectId: $subjectId,
              classifier: OUTDATED
            }) {
              clientMutationId
            }
          }`;

          const query = `mutation AddComment($body: String!, $subjectId: ID!) {
            addComment(input: {
              body: $body,
              subjectId: $subjectId,
            }) {
              subject {
                id
                ... on PullRequest {
                  number
                }
              }
            }
          }`

          const comments = await github.graphql(oldCommentQuery, {
            owner: context.repo.owner,
            name: context.repo.repo,
            number: parseInt(process.env.PULL_REQUEST_NUMBER, 10)
          });

          for (const comment of comments?.repository?.pullRequest?.comments?.nodes ?? []) {
            if (!comment.isMinimized && comment.bodyText.startsWith("Sigma Rule Integrations")) {
              await github.graphql(minimizeCommentMutation, {
                subjectId: comment.id
              });
            }
          }

          const variables = {
            body: comment,
            subjectId: nodeId
          };

          await github.graphql(query, variables);

          return '';
